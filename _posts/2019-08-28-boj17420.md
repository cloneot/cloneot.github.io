title: "백준 17420 깊콘이 넘쳐흘러"

date: 2019-08-28 00:11:00

categories:

- problem solving

tags:

- 17420
- 선린 정보 알고리즘경시대회



# 백준 17420 깊콘이 넘쳐흘러

#### 문제링크

https://www.acmicpc.net/problem/17420



#### 풀이

문제를 간단하게 요약하면, 



모든 i(1 <= i <= n)에 대해 a<sub>i</sub> >= b<sub>i</sub>가 성립하고, 모든 쌍 i, j(1 <= i < j <= n)에 대해 a<sub>i</sub> <= a<sub>j</sub> 와 b<sub>i</sub> <= b<sub>j</sub> 가 성립하도록 적당히 순서를 바꾸고 a<sub>i</sub>에 30단위씩 더하면서 목표로 하는 상태를 만들 때, 30을 더하는 최소 횟수를 구하는 것입니다.



일단 b<sub>i</sub>은 변경이 불가능하니 b<sub>i</sub>를 기준으로 하여 정렬합니다.



b<sub>i</sub> < b<sub>j</sub>일 떄는 



#### 전체 코드

``` C++ 
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<ll, ll> pll;

bool cmp(pll a, pll b)
{
    if(a.second != b.second)    return a.second < b.second;
    return a.first < b.first;
}

int main(void)
{
    ios_base::sync_with_stdio(0);   cin.tie(0);
    int n;
    cin >> n;
    vector<pll> arr(n);
    for(int i = 0; i < n; ++i)  cin >> arr[i].first;
    for(int i = 0; i < n; ++i)  cin >> arr[i].second;

    sort(arr.begin(), arr.end(), cmp);

    ll ans = 0, prev_max = 0;

    for(int i = 0; i < n; )
    {
        int j = i;
        ll cur_max = 0;
        while(j < n && arr[i].second == arr[j].second)
        {
            if(max(prev_max, arr[j].second) > arr[j].first)
            {
                ll cnt = (max(prev_max, arr[j].second) - arr[j].first + 29) / 30;
                ans += cnt;
                arr[j].first += 30 * cnt;
            }
            cur_max = max(cur_max, arr[j].first);
            ++j;
        }
        prev_max = cur_max;
        i = j;
    }
    cout << ans;
    return 0;
}
```

